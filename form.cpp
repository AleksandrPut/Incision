//==============================================================================
//  WARNING!!  This file is overwritten by the Block UI Styler while generating
//  the automation code. Any modifications to this file will be lost after
//  generating the code again.
//
//       Filename:  C:\Users\putilov_aa\Desktop\NX_test\form.cpp
//
//        This file was generated by the NX Block UI Styler
//        Created by: putilov_aa
//              Version: NX 10
//              Date: 12-05-2023  (Format: mm-dd-yyyy)
//              Time: 12:37 (Format: hh-mm)
//
//==============================================================================

//==============================================================================
//  Purpose:  This TEMPLATE file contains C++ source to guide you in the
//  construction of your Block application dialog. The generation of your
//  dialog file (.dlx extension) is the first step towards dialog construction
//  within NX.  You must now create a NX Open application that
//  utilizes this file (.dlx).
//
//  The information in this file provides you with the following:
//
//  1.  Help on how to load and display your Block UI Styler dialog in NX
//      using APIs provided in NXOpen.BlockStyler namespace
//  2.  The empty callback methods (stubs) associated with your dialog items
//      have also been placed in this file. These empty methods have been
//      created simply to start you along with your coding requirements.
//      The method name, argument list and possible return values have already
//      been provided for you.
//==============================================================================

//------------------------------------------------------------------------------
//These includes are needed for the following template code
//------------------------------------------------------------------------------
#include "form.hpp"
using namespace NXOpen;
using namespace NXOpen::BlockStyler;

//std::string *mass_str;


std::vector<string> name_drawing;
std::vector<string> name_view;
std::vector<string> name_label;
std::vector<tag_t> tag_label;
std::vector<tag_t> tag_node;
std::vector<unsigned int> prefix_label;

#define UF_CALL(X) (report( __FILE__, __LINE__, #X, (X)))
static int report(char* file, int line, char* call, int irc)
{
    if (irc)
    {
        char    messg[133];
        printf("%s, line %d:  %s\n", file, line, call);
        (UF_get_fail_message(irc, messg)) ?
            printf("    returned a %d\n", irc) :
            printf("    returned error %d:  %s\n", irc, messg);
    }
    return(irc);
}



void search_name();
void rename_label(int columnID, NXString editedText);

tag_t test_tag;
void test(int columnID);


//------------------------------------------------------------------------------
// Initialize static variables
//------------------------------------------------------------------------------
Session *(form::theSession) = NULL;
UI *(form::theUI) = NULL;
//------------------------------------------------------------------------------
// Constructor for NX Styler class
//------------------------------------------------------------------------------
form::form()
{
    try
    {
        // Initialize the NX Open C++ API environment
        form::theSession = NXOpen::Session::GetSession();
        form::theUI = UI::GetUI();
        //theDlxFileName = "C:\\Users\\putilov_aa\\source\\repos\\Incision\\Incision\\form.dlx";
        theDlxFileName = "form.dlx";
        theDialog = form::theUI->CreateDialog(theDlxFileName);
        // Registration of callback functions
        theDialog->AddApplyHandler(make_callback(this, &form::apply_cb));
        theDialog->AddOkHandler(make_callback(this, &form::ok_cb));
        theDialog->AddUpdateHandler(make_callback(this, &form::update_cb));
        theDialog->AddInitializeHandler(make_callback(this, &form::initialize_cb));
        theDialog->AddDialogShownHandler(make_callback(this, &form::dialogShown_cb));
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        throw;
    }
}

//------------------------------------------------------------------------------
// Destructor for NX Styler class
//------------------------------------------------------------------------------
form::~form()
{
    if (theDialog != NULL)
    {
        delete theDialog;
        theDialog = NULL;
    }
}
//------------------------------- DIALOG LAUNCHING ---------------------------------
//
//    Before invoking this application one needs to open any part/empty part in NX
//    because of the behavior of the blocks.
//
//    Make sure the dlx file is in one of the following locations:
//        1.) From where NX session is launched
//        2.) $UGII_USER_DIR/application
//        3.) For released applications, using UGII_CUSTOM_DIRECTORY_FILE is highly
//            recommended. This variable is set to a full directory path to a file 
//            containing a list of root directories for all custom applications.
//            e.g., UGII_CUSTOM_DIRECTORY_FILE=$UGII_ROOT_DIR\menus\custom_dirs.dat
//
//    You can create the dialog using one of the following way:
//
//    1. USER EXIT
//
//        1) Create the Shared Library -- Refer "Block UI Styler programmer's guide"
//        2) Invoke the Shared Library through File->Execute->NX Open menu.
//
//------------------------------------------------------------------------------
extern "C" DllExport void  ufusr(char *param, int *retcod, int param_len)
{
    form *theform = NULL;
    try
    {
        theform = new form();
        static unsigned char* c;
        c = { nxauthblock };
        // The following method shows the dialog immediately
        theform->Show();
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        form::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
    if(theform != NULL)
    {
        delete theform;
        theform = NULL;
    }
}

//------------------------------------------------------------------------------
// This method specifies how a shared image is unloaded from memory
// within NX. This method gives you the capability to unload an
// internal NX Open application or user  exit from NX. Specify any
// one of the three constants as a return value to determine the type
// of unload to perform:
//
//
//    Immediately : unload the library as soon as the automation program has completed
//    Explicitly  : unload the library from the "Unload Shared Image" dialog
//    AtTermination : unload the library when the NX session terminates
//
//
// NOTE:  A program which associates NX Open applications with the menubar
// MUST NOT use this option since it will UNLOAD your NX Open application image
// from the menubar.
//------------------------------------------------------------------------------
extern "C" DllExport int ufusr_ask_unload()
{
    //return (int)Session::LibraryUnloadOptionExplicitly;
    return (int)Session::LibraryUnloadOptionImmediately;
    //return (int)Session::LibraryUnloadOptionAtTermination;
}

//------------------------------------------------------------------------------
// Following method cleanup any housekeeping chores that may be needed.
// This method is automatically called by NX.
//------------------------------------------------------------------------------
extern "C" DllExport void ufusr_cleanup(void)
{
    try
    {
        //---- Enter your callback code here -----
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        form::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
}

int form::Show()
{
    try
    {
        theDialog->Show();
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        form::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
    return 0;
}

//------------------------------------------------------------------------------
//---------------------Block UI Styler Callback Functions--------------------------
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
//Callback Name: initialize_cb
//------------------------------------------------------------------------------
void form::initialize_cb()
{
    try
    {
        group0 = dynamic_cast<NXOpen::BlockStyler::Group*>(theDialog->TopBlock()->FindBlock("group0"));
        tree_control0 = dynamic_cast<NXOpen::BlockStyler::Tree*>(theDialog->TopBlock()->FindBlock("tree_control0"));

       
        //------------------------------------------------------------------------------
        //Registration of Treelist specific callbacks
        //------------------------------------------------------------------------------
        //tree_control0->SetOnExpandHandler(make_callback(this, &form::OnExpandCallback));
        //tree_control0->SetOnInsertColumnHandler(make_callback(this, &form::OnInsertColumnCallback));
        //tree_control0->SetOnInsertNodeHandler(make_callback(this, &form::OnInsertNodeCallback));
        //tree_control0->SetOnDeleteNodeHandler(make_callback(this, &form::OnDeleteNodeCallback));
        //tree_control0->SetOnPreSelectHandler(make_callback(this, &form::OnPreSelectCallback));
        //tree_control0->SetOnSelectHandler(make_callback(this, &form::OnSelectCallback));
        //tree_control0->SetOnStateChangeHandler(make_callback(this, &form::OnStateChangeCallback));
        //tree_control0->SetToolTipTextHandler(make_callback(this, &form::ToolTipTextCallback));
        //tree_control0->SetColumnSortHandler(make_callback(this, &form::ColumnSortCallback));
        //tree_control0->SetStateIconNameHandler(make_callback(this, &form::StateIconNameCallback));
        tree_control0->SetOnBeginLabelEditHandler(make_callback(this, &form::OnBeginLabelEditCallback));
        tree_control0->SetOnEndLabelEditHandler(make_callback(this, &form::OnEndLabelEditCallback));
        //tree_control0->SetOnEditOptionSelectedHandler(make_callback(this, &form::OnEditOptionSelectedCallback));
        //tree_control0->SetAskEditControlHandler(make_callback(this, &form::AskEditControlCallback));
        //tree_control0->SetOnMenuHandler(make_callback(this, &form::OnMenuCallback));
        //tree_control0->SetOnMenuSelectionHandler(make_callback(this, &form::OnMenuSelectionCallback));
        //tree_control0->SetIsDropAllowedHandler(make_callback(this, &form::IsDropAllowedCallback));
        //tree_control0->SetIsDragAllowedHandler(make_callback(this, &form::IsDragAllowedCallback));
        //tree_control0->SetOnDropHandler(make_callback(this, &form::OnDropCallback));
        //tree_control0->SetOnDropMenuHandler(make_callback(this, &form::OnDropMenuCallback));
        //tree_control0->SetOnDefaultActionHandler(make_callback(this, &form::OnDefaultAction));
        //------------------------------------------------------------------------------
        //tree_control0->GetProperties()->SetInteger("Height", 900);
        //tree_control0->GetProperties()->SetInteger("Width", 900);
        search_name();
        //tree_control0->SetWidth(900);
        
        
        
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        form::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
}

//------------------------------------------------------------------------------
//Callback Name: dialogShown_cb
//This callback is executed just before the dialog launch. Thus any value set 
//here will take precedence and dialog will be launched showing that value. 
//------------------------------------------------------------------------------
void form::dialogShown_cb()
{
    try
    {
        //---- Enter your callback code here -----
        tree_control0->InsertColumn(0, "Section name", 150);
        tree_control0->InsertColumn(1, "Label", 100);
        //tree_control0->InsertColumn(2, "Size", 100);

        for(int i = 0; i < name_view.size(); ++i)
        { 
            Node* rootNode = this->tree_control0->CreateNode(name_view[i].c_str());
            this->tree_control0->InsertNode(rootNode, NULL, NULL, Tree::NodeInsertOptionSort);

            //UF_UI_write_listing_window(("name_view - " + name_view[i]).c_str());
            //UF_UI_write_listing_window("\n");
            /*for (int c = 0; c < name_view.size(); ++c)
            {
                Node* node = this->tree_control0->CreateNode(name_view[c]);
                this->tree_control0->InsertNode(node, rootNode, NULL, Tree::NodeInsertOptionSort);
            }*/
            rootNode->SetColumnDisplayText(1, name_label[i].c_str());
            //rootNode->SetColumnDisplayText(2, std::to_string(prefix_label[i]).c_str());
            tag_node.push_back(rootNode->Tag());
        }

    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        form::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
}

//------------------------------------------------------------------------------
//Callback Name: apply_cb
//------------------------------------------------------------------------------
int form::apply_cb()
{
    int errorCode = 0;
    try
    {
        //---- Enter your callback code here -----
        //tree_control0->DeleteNode(selectedNodes[0]);  
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        errorCode = 1;
        form::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
    return errorCode;
}

//------------------------------------------------------------------------------
//Callback Name: update_cb
//------------------------------------------------------------------------------
int form::update_cb(NXOpen::BlockStyler::UIBlock* block)
{
    try
    {
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        form::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
    return 0;
}

//------------------------------------------------------------------------------
//Callback Name: ok_cb
//------------------------------------------------------------------------------
int form::ok_cb()
{
    int errorCode = 0;
    try
    {
        errorCode = apply_cb();
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        errorCode = 1;
        form::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
    return errorCode;
}
//------------------------------------------------------------------------------
//Treelist specific callbacks
//------------------------------------------------------------------------------
//void form::OnExpandCallback (NXOpen::BlockStyler::Tree *tree, NXOpen::BlockStyler::Node *node)
//{
//}

//void form::OnInsertColumnCallback(NXOpen::BlockStyler::Tree *tree, NXOpen::BlockStyler::Node *node, int columnID)
//{
//}

//void form::OnInsertNodeCallback(NXOpen::BlockStyler::Tree *tree, NXOpen::BlockStyler::Node *node)
//{
//}

//void form::OnDeleteNodeCallback(NXOpen::BlockStyler::Tree *tree, NXOpen::BlockStyler::Node *node)
//{
//}

//void form::OnPreSelectCallback(NXOpen::BlockStyler::Tree *tree, NXOpen::BlockStyler::Node *node, int ID, bool selected)
//{
//}

//void form::OnSelectCallback(NXOpen::BlockStyler::Tree *tree, NXOpen::BlockStyler::Node *node, int columnID, bool selected)
//{
//}

//void form::OnStateChangeCallback(NXOpen::BlockStyler::Tree *tree, NXOpen::BlockStyler::Node *node, int state)
//{
//}

//NXString form::ToolTipTextCallback(NXOpen::BlockStyler::Tree *tree, NXOpen::BlockStyler::Node *node, int columnID)
//{
//}

//int form::ColumnSortCallback(NXOpen::BlockStyler::Tree *tree, int columnID, NXOpen::BlockStyler::Node *node1, NXOpen::BlockStyler::Node *node2)
//{
//}

//NXString form::StateIconNameCallback(NXOpen::BlockStyler::Tree *tree, NXOpen::BlockStyler::Node *node, int state)
//{
//}

NXOpen::BlockStyler::Tree::BeginLabelEditState form::OnBeginLabelEditCallback(NXOpen::BlockStyler::Tree *tree, NXOpen::BlockStyler::Node *node, int columnID)
{
    return Tree::BeginLabelEditStateAllow;
}

NXOpen::BlockStyler::Tree::EndLabelEditState form::OnEndLabelEditCallback(NXOpen::BlockStyler::Tree *tree, NXOpen::BlockStyler::Node *node, int columnID, NXString editedText)
{
    {
        if (columnID == 1)
        {
            rename_label(node->Tag(), editedText);
            return Tree::EndLabelEditStateAcceptText;
        }
        /*if (columnID == 2)
        {
            auto index_pref = find(prefix_label.begin(), prefix_label.end(), columnID);
            //unsigned int pref = prefix_label[index_pref - prefix_label.begin()];

            prefix_label.insert(index_pref, atoi(editedText.GetLocaleText()));
            //return Tree::BeginLabelEditStateAllow;
        }*/
        
    }
}

//NXOpen::BlockStyler::Tree::EditControlOption form::OnEditOptionSelectedCallback(NXOpen::BlockStyler::Tree *tree, NXOpen::BlockStyler::Node *node, int columnID, int selectedOptionID, NXString selectedOptionText, NXOpen::BlockStyler::Tree::ControlType type)
//{
//}

//NXOpen::BlockStyler::Tree::ControlType form::AskEditControlCallback(NXOpen::BlockStyler::Tree *tree, NXOpen::BlockStyler::Node *node, int columnID)
//{
//}

//void form::OnMenuCallback(NXOpen::BlockStyler::Tree *tree, NXOpen::BlockStyler::Node *node, int columnID )
//{
//}

//void form::OnMenuSelectionCallback(NXOpen::BlockStyler::Tree *tree, NXOpen::BlockStyler::Node *node, int menuItemID)
//{
//}

//NXOpen::BlockStyler::Node::DropType form::IsDropAllowedCallback(NXOpen::BlockStyler::Tree *tree, NXOpen::BlockStyler::Node *node, int columnID, NXOpen::BlockStyler::Node *targetNode, int targetColumnID)
//{
//}

//NXOpen::BlockStyler::Node::DragType form::IsDragAllowedCallback(NXOpen::BlockStyler::Tree *tree, NXOpen::BlockStyler::Node *node, int columnID)
//{
//}

//bool form::OnDropCallback(NXOpen::BlockStyler::Tree *tree, std::vector<NXOpen::BlockStyler::Node *> node, int columnID, NXOpen::BlockStyler::Node *targetNode, int targetColumnID, NXOpen::BlockStyler::Node::DropType dropType, int dropMenuItemId)
//{
//}

//void form::OnDropMenuCallback(NXOpen::BlockStyler::Tree *tree, NXOpen::BlockStyler::Node *node, int columnID, NXOpen::BlockStyler::Node *targetNode, int targetColumnID)
//{
//}

//void form::OnDefaultAction(NXOpen::BlockStyler::Tree *tree, NXOpen::BlockStyler::Node *node, int columnID)
//{
//}


//------------------------------------------------------------------------------
//Function Name: GetBlockProperties
//Description: Returns the propertylist of the specified BlockID
//------------------------------------------------------------------------------
PropertyList* form::GetBlockProperties(const char *blockID)
{
    return theDialog->GetBlockProperties(blockID);
}


void search_name()
{
    //UF_UI_open_listing_window();
    int         ifail = 0;
    ifail = UF_initialize();
    int num_drawings = 0, num_views = 0;
    tag_p_t Drawing_tags = NULL, view_list = NULL;
    char name_draw[UF_OBJ_NAME_LEN + 1];
    char name[UF_OBJ_NAME_LEN + 1];
    UF_VIEW_type_t type;
    UF_VIEW_subtype_t subtype;
    tag_t view_label_tag = NULL_TAG;
    UF_DRF_label_info_t* label_info;
    UF_DRAW_view_label_parms_t view_label_parms;
    char* string_value;
    logical has_attribute;

    //Находим все листы чертежа
    UF_DRAW_ask_drawings(&num_drawings, &Drawing_tags);
    for (int i = 0; i < num_drawings; ++i)
    {
        // Получаем список тегов вида для n чертежа 
        UF_DRAW_ask_views(Drawing_tags[i], &num_views, &view_list);
        UF_OBJ_ask_name(Drawing_tags[i], name_draw);
        name_drawing.push_back(name_draw);
        for (int x = 0; x < num_views; ++x)
        {
            
            //Получаем тип и подтип для каждого вида
            UF_VIEW_ask_type(view_list[x], &type, &subtype);
            if (type == UF_VIEW_DRAWING_MEMBER_TYPE && subtype == UF_VIEW_SECTION_SUBTYPE)//UF_VIEW_DRAWING_MEMBER_TYPE = 1 UF_VIEW_SECTION_SUBTYPE = 0
            {
                UF_OBJ_ask_name(view_list[x], name);
                name_view.push_back(name);

                //Получаем тег надписи разреза
                UF_DRAW_ask_view_label(view_list[x], &view_label_tag);

                UF_DRAW_ask_view_label_parms(view_label_tag, &view_label_parms);
                UF_ATTR_get_string_user_attribute(view_list[x], "VWLETTER_DISP", UF_ATTR_NOT_ARRAY, &string_value, &has_attribute);

                string str = (string)string_value;
                string copy_str, str_2;
                for (int i = 0; i < str.size(); ++i)
                {
                    if (str[i] == '<')
                        break;
                    copy_str[i] = str[i];
                }
                strcpy(const_cast<char*>(str_2.c_str()), copy_str.c_str());
                name_label.push_back(str_2);
                //prefix_label.push_back(1);
                //name_label.push_back((string)view_label_parms.view_letter);
                tag_label.push_back(view_list[x]);
            }
        }
    }
    UF_free(Drawing_tags);
    ifail = UF_terminate();
}

void rename_label(int columnID, NXString editedText)
{
    Session* theSession = Session::GetSession();
    Part* workPart(theSession->Parts()->Work());
    Part* displayPart(theSession->Parts()->Display());

    tag_t view_label_tag;
    char* string_value;
    char* string_value2;
    char string_label_value[200];
    logical has_attribute;
    //logical has_attribute2;
    std::string new_labelSTR, new_labelSTR_2;
    auto index = find(tag_node.begin(), tag_node.end(), columnID);
    tag_t view_tag = tag_label[index - tag_node.begin()];

    //auto index_pref = find(prefix_label.begin(), prefix_label.end(), columnID + 1);
    //unsigned int pref = prefix_label[index_pref - prefix_label.begin()];
    
    //UF_UI_open_listing_window();
    //UF_UI_write_listing_window(std::to_string(pref).c_str());



    NXString nstr(editedText.GetLocaleText(), NXString::UTF8);

    //Получаем тег надписи разреза
    UF_DRAW_ask_view_label(view_tag, &view_label_tag);

    //Получаем значение атрибута с именем "VWLETTER_DISP"
    UF_ATTR_get_string_user_attribute(view_tag, "VWLETTER_DISP", UF_ATTR_NOT_ARRAY, &string_value, &has_attribute);

    std::string strin0 = (string)string_value;
    auto slashPosition0 = strin0.find_first_of("<"); // начиная с 11 плюсов
    //strin.erase(strin.begin() + slashPosition, strin.end()); // с начала
    strin0.erase(strin0.begin(), strin0.begin() + slashPosition0); //с конца

    std::string strin4 = strin0;
    auto slashPosition4 = strin4.find_first_of(">"); // начиная с 11 плюсов
    strin4.erase(strin4.begin() + slashPosition4+1, strin4.end()); // с начала
    //strin4.erase(strin4.begin(), strin4.begin() + slashPosition4); //с конца

    //Меняем и копируем
    new_labelSTR = (string)nstr.GetLocaleText() + strin4 + "<L>";
    strcpy(string_value, new_labelSTR.c_str());

    string str = (string)nstr.GetLocaleText();
    string copy_symbol_str;
    string copy_str;
    int count = 0;
    for (int i = 1; i < str.size(); ++i)
    {
        copy_str[count] = str[i];
        count++;
    }
    //for (int i = 0; i < pref; ++i)
    //{
        copy_symbol_str[0] = str[0];
    //}
   
    //strcpy(string_value2, (char*)str[0]);
    NXString nstr2(copy_str, NXString::Locale);
    NXString nstr3(copy_symbol_str, NXString::Locale);
    bool start = true;
    try
    {
        //Замена символа на отоброжаемой иерархии 
        std::vector<NXOpen::View*> views1;
        NXOpen::Drawings::SectionView* sectionView1(dynamic_cast<NXOpen::Drawings::SectionView*>(NXObjectManager::Get(view_tag)));

        views1.push_back(sectionView1);
        NXOpen::Drawings::EditViewSettingsBuilder* editViewSettingsBuilder2;
        editViewSettingsBuilder2 = workPart->SettingsManager()->CreateDrawingEditViewSettingsBuilder(views1);

        std::vector<NXOpen::Drafting::BaseEditSettingsBuilder*> editsettingsbuilders2;
        editsettingsbuilders2.push_back(editViewSettingsBuilder2);
        workPart->SettingsManager()->ProcessForMultipleObjectsSettings(editsettingsbuilders2);

        editViewSettingsBuilder2->ViewCommonViewLabel()->SetLetter(nstr3);

        NXOpen::NXObject* nXObject2;
        nXObject2 = editViewSettingsBuilder2->Commit();
        editViewSettingsBuilder2->Destroy();
    }
    catch (exception& ex)
    {
        start = false;
        uc1601(const_cast<char*>("Такой символ уже используется"), 1);
    }

    if(start)
    { 
        UF_ATTR_set_string_user_attribute(view_tag, "VWLETTER", UF_ATTR_NOT_ARRAY, (char*)nstr3.GetText(), &has_attribute);
        UF_ATTR_set_string_user_attribute(view_tag, "VWLETTER_DISP", UF_ATTR_NOT_ARRAY, string_value, &has_attribute);

        std::vector<NXOpen::DisplayableObject*> viewlabels1;
        NXOpen::Annotations::Note* note3(dynamic_cast<NXOpen::Annotations::Note*>(NXObjectManager::Get(view_label_tag)));
        viewlabels1.push_back(note3);

        NXOpen::Drawings::EditViewLabelSettingsBuilder* editViewLabelSettingsBuilder1;
        editViewLabelSettingsBuilder1 = workPart->SettingsManager()->CreateDrawingEditViewLabelSettingsBuilder(viewlabels1);

        std::vector<NXOpen::Drafting::BaseEditSettingsBuilder*> editsettingsbuilders1;
        editsettingsbuilders1.push_back(editViewLabelSettingsBuilder1);
        workPart->SettingsManager()->ProcessForMultipleObjectsSettings(editsettingsbuilders1);

        editViewLabelSettingsBuilder1->ViewSectionLabel()->SetCustomizedViewLabel(true);

        std::vector<NXString> customizedtext1;
        NXOpen::Drawings::ViewSectionLabelBuilder* ViewSectionLabel(editViewLabelSettingsBuilder1->ViewSectionLabel());
        std::vector<NXString> GetCustomizedViewLabelText(ViewSectionLabel->GetCustomizedViewLabelText());


        //Формируем строку --> <C2.0000><W & Ref1 * 0@VWLETTER_DISP>-<W & Ref1 * 0@VWLETTER_DISP><C>
        std::string strin = (string)GetCustomizedViewLabelText[0].GetText();
        auto slashPosition = strin.find_first_of("-"); // начиная с 11 плюсов
        //strin.erase(strin.begin() + slashPosition, strin.end()); // с начала
        strin.erase(strin.begin(), strin.begin() + slashPosition + 1); //с конца

        std::string strin1 = (string)GetCustomizedViewLabelText[0].GetText();
        auto slashPosition1 = strin1.find_first_of('@'); // начиная с 11 плюсов
        strin1.erase(strin1.begin() + slashPosition1, strin1.end()); // с начала

        std::string strin2 = strin;
        auto slashPosition2 = strin2.find_first_of('@'); // начиная с 11 плюсов
        strin2.erase(strin2.begin() + slashPosition2, strin2.end()); // с начала

        /*UF_UI_write_listing_window(strin1.c_str());
        UF_UI_write_listing_window("\n");
        UF_UI_write_listing_window(strin2.c_str());
        UF_UI_write_listing_window("\n");
        UF_UI_write_listing_window(strin.c_str());
        UF_UI_write_listing_window("\n");

        UF_UI_write_listing_window("########################");
        UF_UI_write_listing_window("\n");*/

        new_labelSTR_2 = (strin1 + "@VWLETTER>-" + strin2 + "@VWLETTER>" + (string)nstr2.GetLocaleText() + "<C>");
        strcpy(string_label_value, new_labelSTR_2.c_str());
        customizedtext1.push_back(string_label_value);

        editViewLabelSettingsBuilder1->ViewSectionLabel()->SetCustomizedViewLabelText(customizedtext1);

        NXOpen::NXObject* nXObject1;
        nXObject1 = editViewLabelSettingsBuilder1->Commit();
        editViewLabelSettingsBuilder1->Destroy();
    }
}

/*
void test(int columnID)
{ 
    
    NXOpen::Session* theSession = NXOpen::Session::GetSession();
    NXOpen::Part* workPart(theSession->Parts()->Work());
    NXOpen::Part* displayPart(theSession->Parts()->Display());

    auto index = find(tag_node.begin(), tag_node.end(), columnID);
    tag_t view_tag = tag_label[index - tag_node.begin()];

    tag_t view_label_tag;
    //Получаем тег надписи разреза
    //UF_DRAW_ask_view_label(test_tag, &view_label_tag);
    //auto n = find(tag_node.begin(), tag_node.end(), columnID);
    //UF_UI_write_listing_window(std::to_string(n - tag_node.begin()).c_str());
    //UF_UI_write_listing_window("\n");
    //UF_UI_write_listing_window(std::to_string(tag_label[n - tag_node.begin()]).c_str());
    //UF_UI_write_listing_window("\n");
    //UF_UI_write_listing_window(std::to_string(tag_label[columnID - 1]).c_str());
    //UF_UI_write_listing_window(std::to_string(columnID).c_str());


    UF_UI_write_listing_window("\n");
    int type, subtype;
    char name[UF_OBJ_NAME_LEN + 1];
    tag_t part_tag = UF_ASSEM_ask_work_part() , obj_tag = NULL_TAG;
    tag_t t[200];
    int i = 0;
    do
    {
        obj_tag = UF_OBJ_cycle_all(part_tag, obj_tag);

        UF_OBJ_ask_type_and_subtype(obj_tag, &type, &subtype);//UF_view_type     UF_view_section_subtype
        if(type == UF_drafting_entity_type && subtype == UF_draft_note_subtype)
        { 
            UF_OBJ_ask_name(obj_tag, name);
            UF_OBJ_set_color(obj_tag, UF_DISP_PALE_WEAK_GREEN_NAME);
            t[i] = obj_tag;
            i++;
            UF_UI_write_listing_window(("tag - " + std::to_string(obj_tag)).c_str());
            UF_UI_write_listing_window("\n");
        }
        if (type == UF_section_line_type)// && subtype == UF_tabular_note_section_subtype)//UF_section_segment_type  UF_arrow_segment_subtype  UF_cut_segment_subtype                  
        {
            
        }
        
    } while (obj_tag != NULL_TAG); 
    for (int u = 0; u < i; ++u)
    {
        UF_UI_write_listing_window(("***** tag - " + std::to_string(t[u])).c_str());
        UF_UI_write_listing_window("\n");


       

        //UF_DRF_add_assortpart_to_ann(view_tag, 1, &note_tag);

        //UF_OBJ_delete_object(t[u]);
        //UF_OBJ_set_color(obj_tag, UF_OBJ_RED);
    }

    UF_DRAW_view_label_parms_s view_label_parms;
    //Получаем структуру параметров надписи разреза
    UF_DRAW_ask_view_label_parms(view_label_tag, &view_label_parms);
    //int
    view_label_parms.view_label_parm_type = UF_DRAW_view_label_section_view;
    view_label_parms.view_label_type = UF_DRAW_view_label_prefix_and_letter;// UF_DRAW_view_label_view_name; 
    view_label_parms.letter_format = UF_DRAW_view_label_dashed_letter;//UF_DRAW_view_label_single_letter;//UF_DRAW_view_label_dashed_letter
    view_label_parms.view_label_position = UF_DRAW_view_label_below_boundary;
    view_label_parms.view_scale_position = UF_DRAW_view_label_after;
    view_label_parms.view_scale_value_format = UF_DRAW_view_label_vertical_fraction;
    view_label_parms.view_label_text_to_stub_format = UF_DRAW_parent_view_label_text_before_stub;
    view_label_parms.parent_label_type = UF_DRAW_parent_view_label_boundary;//UF_DRAW_parent_view_label_note; //
    view_label_parms.secondary_indexing_align = UF_DRAW_secondary_indexing_inline;
    //double
    view_label_parms.letter_size_factor = 2;
    view_label_parms.view_scale_prefix_factor = 2;
    view_label_parms.view_scale_text_factor = 2;
    view_label_parms.text_to_gap_factor = 2;     
    view_label_parms.subscript_size_factor = 2;
    //bool
    view_label_parms.view_label = true;
    view_label_parms.scale_label = true;
    view_label_parms.view_label_customize = true;
    view_label_parms.scale_parentheses = true;
    view_label_parms.show_rotation_symbol = true;
    view_label_parms.show_rotation_angle = true;
    //char
    view_label_parms.view_label_prefix[0] = '(';// "<С><SECTION>(1)<С>";
    view_label_parms.scale_label_prefix[0] = '8';
    strcpy(view_label_parms.view_letter, "<C2.0000><W&Ref1*0@VWLETTER_DISP>-<W&Ref1*0@VWLETTER_DISP>(2)<C>");
    view_label_parms.parent_vw_lbl_prefix[0] = '1';
 
    //UF_DRAW_set_view_label_parms(view_tag, &view_label_parms);
    //Заполняем структуру для каждого разреза 
    UF_DRAW_create_view_label(view_tag, &view_label_parms, &view_label_tag);



    int                           ifail = 0;
    int                           num_text;
    tag_t                         draft_aid_tag = NULL_TAG;
    char                          error_message[133] = "";
    UF_DRF_draft_aid_text_info_t* text_info;
    UF_OBJ_cycle_objs_in_part(UF_ASSEM_ask_work_part(), UF_drafting_entity_type, &draft_aid_tag);
    UF_DRF_ask_draft_aid_text_info(draft_aid_tag, &num_text, &text_info);

    UF_DRF_free_text(num_text, &text_info);

    Session::UndoMarkId markId1;
    markId1 = theSession->SetUndoMark(Session::MarkVisibilityVisible, "Start Edit Section Lince Color");

    Drawings::SectionLineCollection::iterator sxiterator = workPart->Drafting()->SectionLines()->begin();
    while (sxiterator != workPart->Drafting()->SectionLines()->end())
    {
        Drawings::SectionLine* sxline = sxiterator.operator*();

        Drawings::SectionLineStyleBuilder* styleBuilder;
        styleBuilder = workPart->Drafting()->SectionLines()->CreateSectionLineStyleBuilder(sxline);
        styleBuilder->SetColor(workPart->Colors()->Find("Brown"));

        UF_UI_write_listing_window("\t --- ########################### --- ");
        UF_UI_write_listing_window("\n");

        NXObject* nxObj;
        nxObj = styleBuilder->Commit();
        styleBuilder->Destroy();

        sxiterator.operator++(1);
    }
    theSession->SetUndoMarkName(markId1, "End Edit Section Lince Color");




    //Mechatronics_ObjectSink.hxx
    //Mechatronics_ObjectSinkBuilder.hxx
    //Mechatronics_ObjectSinkCollection.hxx

    //NXOpen::Annotations::Note* note2(dynamic_cast<NXOpen::Annotations::Note*>(NXObjectManager::Get(view_label_tag)));
    NXOpen::Annotations::NoteCollection::iterator noteiterator = workPart->Notes()->begin();
    NXOpen::Annotations::IdSymbolCollection::iterator idSymbols = theSession->Parts()->Work()->Annotations()->IdSymbols()->begin();


    NXOpen::UserDefinedObjects::UserDefinedClassManager* UserDefinedClassManager = theSession->UserDefinedClassManager();

    //NXOpen::CAE::SimConditionCollection::NextLabel;
    //NXOpen::CAE::FEElementLabelMap::AskNextElementLabel;
    //NXOpen::CAE::FENodeLabelMap::AskNextNodeLabel;
    NXOpen::Annotations::Note* note2(dynamic_cast<NXOpen::Annotations::Note*>(NXObjectManager::Get(39062)));

    //NXOpen::Annotations::AssociatedObject* GetAssociatedObject(note2->GetAssociatedObject());
    NXOpen::DisplayableObject* getObjects(dynamic_cast<NXOpen::DisplayableObject*>(NXObjectManager::Get(39062)));
    //note2->GetAssociatedObject()->GetObjectIndex(getObjects[0]);
    //Обозначение линии сечения - ID 81961 r
    //Обозначение линии сечения - ID 81971 l
    tag_t view_tagt;
    while (noteiterator != workPart->Notes()->end())
    {
        NXOpen::Annotations::NoteBase* note1 = noteiterator.operator*();

        NXOpen::Assemblies::Component* OwningComponent = note1->OwningComponent();

        UF_DRAW_ask_view_of_view_label(note1->Tag(), &view_tagt);
        string str = UF_TAG_ask_handle_of_tag(note1->Tag());
        UF_UI_write_listing_window(("\t --- ### str ## --- " + str).c_str());

        UF_UI_write_listing_window(("\t --- ### view ## --- " + std::to_string(view_tagt)).c_str());

        UF_UI_write_listing_window(("\t --- ######## NOTE ########## --- " + std::to_string(note1->Tag())).c_str());
        UF_UI_write_listing_window("\n");

        //NXObject* nxObj;
        //nxObj = styleBuilder->Commit();
        //styleBuilder->Destroy();

        noteiterator.operator++(1);
    }
}*/

